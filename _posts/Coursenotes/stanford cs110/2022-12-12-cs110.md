---
layout: post
title: "[Stanford CS110] Principles of Computer Systems"
date: 2022-12-12 09:00:00 +0800
categories: [Course Notes, stanford cs110]
tags: [Operating System, Computer Systems]
---


Lecture references:
- [<span style="color:#3ababa">Spring 2017 CS110 Archived</span>](http://web.stanford.edu/class/archive/cs/cs110/cs110.1176/spring-2017/) 
- [<span style="color:#3ababa">YouTube Videos</span>](https://www.youtube.com/watch?v=_LFGjZ0Sc6I&list=PLai-xIlqf4JmTNR9aPCwIAOySs1GOm8sQ&index=2) 


## Lecuture 8 Race conditions, deadlock and data integrity
### The Race Condition Checklist
- Identify shared data that may be modified concurrently
    what global variables are used in both the main code and signal handler?
- Document and confirm an ordering of events that caused unexpected behavior
    what assumptions are made in the code that can be broken by certain orderings?
- Use concurrency directives to force expected orderings
    how can we use signal blokcing and atomic operations to force the correct ordering(s)?

## Lecuture 11 Multithreading and Condition Variables
When coding with threads, you need to ensure that:
- there are no race conditions, even if they rarely cause problems, and
- there is zero threat of deadlock, lest a subset of threads are forever starving for processor time

mutexes are generally the solution to race conditions. We can use them to mark the boundaries of critical regions and limit the number of threads present within them to be at most one.

Deadlock can be programmatically prevented by implanting directives to limit the number of threads competing for a shared resource.

## Lecuture 12 mutex, conditional_variable_any, semaphore

### 1. The general pattern of conditional_variable_any
```
static void waitForPermission(size_t& permits, condition_variable_any& cv, mutex& m) {
    lock_guard<mutex> lg(m);
    while(permits == 0) 
        cv.wait(m);
    permits--;
}

static void grantPermission(size_t& permits, condition_variable_any& cv, mutex& m) {
    lock_guard<mutex> lg(m);
    permits++;
    if(permits == 1) 
        cv.notify_all();
}
```

A second form of wait() is useful because the while loop is very common:
```
template <Predicate pred>
void condition_variable_any::wait(mutex& m, Pred pred) {
    while(!pred()) wait(m);
}
```

The predicate is a function that returns true of false. We often use a lambda function for the predicate:
```
static void waitForPermission(size_t& permits, condition_variable_any& cv, mutex& m) {
    lock_guard<mutex> lg(m);
    cv.wait(m, [&permits]{ return permits > 0; }); //if true, re-acquire lock and unblocked; else keep waiting, release lock.
    permits--;
}
```

### 2. semaphore
It is a useful way to generalize the "permits" idea.

```
constexpr on_thread_exit_t on_thread_exit {};

class semaphore {
public:
    semaphore(int value = 0);
    void wait();
    void signal();
    void signal(on_thread_exit_t ote);

private:
    int value;
    
    std::mutex m;
    std::condition_variable_any cv;

    semaphore(const semaphore& orig) = delete;
    const semaphore& operator=(const semaphore& rhs) const = delete;
};  
```

```
void semaphore::wait() {
    lock_guard<mutex> lg(m);
    cv.wait(m, [this] {return value > 0;});
    value--;
}

void semaphore::signal() {
    lock_guard<mutex> lg(m);
    value++;
    if(value == 1) 
        cv.notify_all();
}
```

Using a semaphore is straightforward: you first declare a semaphore with a number of permits you would like:
```
semaphore permits(5);
```

When a thread wants to use a permit, it first waits for the permit, and then signals when it's done using a permit:
```
permits.wait();   //if five other threads currently hold permits, this will block.
permits.signal(); //if other threads are waiting, a permit will be available.
 
```

*Q1*: what would a semaphore initialized with 0 mean? <br>
*A1*: In this case, we don't have any permits, permits.wait() always has to wait for a signal, and will never stop waiting until that signal is received.
```
semaphore permits(0);
```

*Q2*: What about a negative initializer for a semaphore? <br>
*A2*: In this case, the semaphore would have to reach 1 before the wait would stop waiting. You might want to wait until a bunch of threads finished before a final thread is allowed to continue.


### 3. Thread rendezvous
Thread rendezvous is a generalization of thread::join. It allows one thread to stall - via semaphore::wait - until another thread calls semaphore::signal, often because the signaling thread just prepared some data that the waiting thread needs before it can continue.























